# Hibernate Proxy와 JPA 엔티티 equals/hashCode 설계

## Hibernate Proxy란

Hibernate Proxy는 **지연 로딩(lazy load)**을 위해 Hibernate가 생성하는 **가짜 껍데기 객체** 다.  
실제 엔티티 대신 반환되며, 내부적으로 **식별자(id)**만 보관하고, 나머지 필드는 비워둔 상태다.  
필드나 메서드 접근 시점에 세션을 통해 **SQL을 실행하여 초기화** 한다.

### 동작 방식
1. **프록시 생성**
    - 연관 엔티티를 `fetch = LAZY`로 설정하면 Hibernate는 원본 엔티티 대신 프록시 객체를 반환합니다.
    - 해당 프록시는 `ByteBuddy`나 `CGLIB` 기반의 **서브클래스**입니다.

2. **초기화 트리거**
    - 프록시의 게터 호출, equals에서 특정 필드 접근 등 값이 필요한 시점에 SQL을 실행하여 데이터를 채운다.

3. **클래스 타입 이슈**
    - 프록시는 원본 클래스의 서브클래스이기 때문에, `javaClass` 비교 시 `TransactionJpaEntity`와 `TransactionJpaEntity$$HibernateProxy`처럼 서로 다른 타입으로 인식될 수 있다.

---

## equals/hashCode 설계가 중요시 되는 까닭

- **동등성 비교**(같은 엔티티인지 확인) 시 프록시가 섞여도 일관성 있는 비교가 필요하다.
- `Set`이나 `Map`에 엔티티를 저장할 때 equals/hashCode가 안정적으로 동작해야 한다.
- 잘못된 구현 시, 같은 PK를 가진 객체라도 다르다고 판단하여 데이터 무결성 문제를 유발할 수 있다.

---

## 안전한 equals/hashCode 구현시

Snowflake ID처럼 **엔티티 생성 시점부터 식별자가 항상 존재**하는 경우, PK 기반 equals/hashCode 구현이 가장 안전하다.

```kotlin
override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other == null) return false

    val thisClass = org.hibernate.Hibernate.getClass(this)
    val otherClass = org.hibernate.Hibernate.getClass(other)
    if (thisClass != otherClass) return false

    other as TransactionJpaEntity
    return this.id == other.id
}

override fun hashCode(): Int = id.hashCode()
```

### 포인트
- `Hibernate.getClass()` 사용시 프록시/원본 타입 차이를 무시하고 비교가 가능하다
- `id.hashCode()` 사용시 Snowflake 기반이므로 id가 null일 일이 없어 안전하다
- `==` 비교는 동일성, `equals`는 동등성 확인용으로 사용한다.

---

## 다른 식별자 전략을 쓰는 경우
- JPA가 영속화 시점에 식별자를 할당하는 전략(`GenerationType.IDENTITY` 등)이라면, 영속화 전에는 id가 null일 수 있으므로 hashCode가 변하면 안 된다.
- 이 경우 비즈니스 키 기반 equals/hashCode를 사용하거나, hashCode를 고정값(예: 0)으로 두는 방법을 고려해야 한다.